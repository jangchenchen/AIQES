# 答题考试系统（AI版）- 系统流程图

## 📊 整体架构

```
┌─────────────────────────────────────────────────┐
│                   用户浏览器                       │
│                                                   │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐         │
│  │ 上传界面 │→│ 答题界面 │→│ 结果界面 │         │
│  └─────────┘  └─────────┘  └─────────┘         │
└───────────────────┬─────────────────────────────┘
                    │ HTTP REST API
┌───────────────────▼─────────────────────────────┐
│              Flask Web Server                    │
│          (web_server.py - Port 5001)            │
│                                                  │
│  ┌──────────────────────────────────────────┐  │
│  │  API Routes                               │  │
│  │  • POST /api/upload-knowledge            │  │
│  │  • POST /api/generate-questions          │  │
│  │  • POST /api/get-question                │  │
│  │  • POST /api/submit-answer               │  │
│  │  • POST /api/session-status              │  │
│  └──────────────────────────────────────────┘  │
└───────────────────┬─────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
┌───────▼────┐ ┌───▼────┐ ┌───▼────┐
│ Knowledge  │ │Question│ │ Record │
│  Loader    │ │Generator│ │Manager│
└────────────┘ └────────┘ └────────┘
        │           │           │
┌───────▼───────────▼───────────▼────┐
│         Data Storage                │
│  • uploads/ (知识文件)              │
│  • data/answer_history.jsonl       │
│  • data/wrong_questions.json        │
│  • AI_cf/cf.json                   │
└─────────────────────────────────────┘
```

---

## 🔄 用户操作流程

### 1. 上传知识文件

```
用户 → 选择文件 (txt/md/pdf)
  ↓
浏览器 → POST /api/upload-knowledge
  ↓
服务器 → 保存到 uploads/
  ↓
知识加载器 → 解析文件内容
  ↓
服务器 → 返回文件路径 + 条目数量
  ↓
浏览器 → 显示文件信息 + 启用"生成题目"按钮
```

### 2. 配置并生成题目

```
用户 → 选择题型 + 设置数量 + 选择顺序
  ↓
浏览器 → POST /api/generate-questions
  ↓
服务器 → 创建会话 (UUID)
  ↓
题目生成器 → 根据知识条目生成题目
  ↓
AI客户端 (可选) → 生成额外AI题目
  ↓
服务器 → 保存会话数据 + 返回会话ID
  ↓
浏览器 → 切换到答题界面
```

### 3. 答题循环

```
浏览器 → POST /api/get-question (会话ID)
  ↓
服务器 → 返回当前题目
  ↓
浏览器 → 渲染题目 + 等待用户答题
  ↓
用户 → 选择/输入答案 + 点击提交
  ↓
浏览器 → POST /api/submit-answer (会话ID + 答案)
  ↓
服务器 → 判分逻辑
  ↓
记录管理器 → 保存答题记录 + 更新错题本
  ↓
服务器 → 返回判分结果 + 解析
  ↓
浏览器 → 显示反馈 + 更新统计
  ↓
用户 → 点击"下一题"
  ↓
(重复答题循环)
```

### 4. 查看结果

```
服务器 → 返回 finished: true
  ↓
浏览器 → 切换到结果界面
  ↓
显示 → 最终得分 + 正确题数/总题数
  ↓
用户 → 点击"重新开始"
  ↓
浏览器 → 重置状态 + 返回上传界面
```

---

## 🧠 判分逻辑流程

### 单选题

```
用户输入: "B"
  ↓
转换索引: B → 1
  ↓
比较: user_idx == correct_idx ?
  ↓
YES → 返回 ✓ 正确
NO  → 返回 ✗ 错误 + 正确答案
```

### 多选题

```
用户输入: "ACD"
  ↓
解析索引: [0, 2, 3]
  ↓
排序: [0, 2, 3]
  ↓
比较: user_set == correct_set ?
  ↓
YES → 返回 ✓ 正确
NO  → 返回 ✗ 错误 + 正确答案
```

### 填空题

```
用户输入: "声光报警"
  ↓
规范化: 转小写 "声光报警"
  ↓
遍历关键词: ["声光报警", "轿门开启"]
  ↓
检查包含: "声光报警" in "声光报警" ?
  ↓
YES → 返回 ✓ 正确 + 匹配的关键词
NO  → 返回 ✗ 错误 + 参考答案
```

### 问答题

```
用户输入: "检查铅封是否完好"
  ↓
规范化: 转小写
  ↓
遍历关键词: ["铅封", "完整", "破坏"]
  ↓
检查包含: 找到任一关键词?
  ↓
YES → 返回 ✓ 正确 + 匹配的关键词列表
NO  → 返回 ✗ 提示参考要点
```

---

## 💾 数据持久化流程

### 答题历史记录

```
用户提交答案
  ↓
判分完成
  ↓
构建记录:
{
  timestamp: "2025-11-04T12:34:56.789Z",
  session_id: "uuid",
  question: {...},
  user_answer: "A",
  is_correct: true,
  plain_explanation: "✓ 回答正确！...",
  session_context: {...}
}
  ↓
追加到文件: data/answer_history.jsonl
(每行一条JSON)
```

### 错题本管理

```
判分结果
  ↓
is_correct == false?
  ↓
YES:
  读取错题本 → 添加/更新题目 → 保存文件
  {
    question: {...},
    last_plain_explanation: "...",
    last_wrong_at: "timestamp"
  }

NO (答对了):
  读取错题本 → 查找题目ID → 移除题目 → 保存文件
```

---

## 🤖 AI 集成流程（可选）

```
用户点击侧边栏"⚙️ AI 配置"
  ↓
新标签页打开: /web/ai-config/index.html
  ↓
用户填写配置:
  - API URL
  - API Key
  - 模型名称
  ↓
点击"测试连通性"
  ↓
发起 HTTP GET 请求 + Bearer Token
  ↓
返回结果: 成功 / 失败
  ↓
点击"保存"
  ↓
写入文件: AI_cf/cf.json
  ↓
前端返回主页
  ↓
用户设置"AI生成题目数量" > 0
  ↓
生成题目时:
  服务器读取 AI 配置
  ↓
  调用 AI API 生成题目
  ↓
  合并到题库
  ↓
  (AI失败不影响主流程)
```

---

## 🔄 会话生命周期

```
1. 创建会话 (生成题目时)
   ↓
   session_id = uuid.uuid4()
   sessions[session_id] = {
     "questions": [...],
     "current_index": 0,
     "answers": [],
     "correct_count": 0,
     "total_count": len(questions),
     "filepath": "..."
   }

2. 使用会话 (答题过程中)
   ↓
   每次提交答案:
     - 更新 current_index
     - 添加 answer 到 answers[]
     - 更新 correct_count

3. 完成会话 (所有题目答完)
   ↓
   current_index >= total_count
   ↓
   返回 finished: true
   ↓
   (会话保留在内存中，可查询历史)

4. 清理会话 (服务器重启后)
   ↓
   内存字典清空
   ↓
   (历史数据已保存到文件，不丢失)
```

---

## 🌐 前端状态管理

```
全局变量:
  - currentFilepath    # 当前上传的文件路径
  - currentSessionId   # 当前答题会话ID
  - currentQuestion    # 当前题目对象
  - selectedOptions    # 当前选中的选项 (Set)
  - answeredCount      # 已答题数
  - correctCount       # 正确题数
  - totalCount         # 总题数

视图切换:
  uploadView  → 上传界面 (初始)
  quizView    → 答题界面
  resultView  → 结果界面

状态更新时机:
  - 文件上传成功 → 启用"生成题目"按钮
  - 题目生成成功 → 切换到答题界面
  - 答案提交成功 → 更新统计 + 显示反馈
  - 所有题目完成 → 切换到结果界面
  - 重新开始 → 重置所有状态
```

---

## 🚀 性能优化流程

### 文件上传优化

```
前端:
  - 拖拽事件优化 (防抖)
  - 文件大小预检 (≤700KB)
  - 文件类型预检 (.txt/.md/.pdf)

后端:
  - 流式上传 (不一次性加载到内存)
  - UUID文件命名 (防冲突)
  - 文件大小限制 (700KB)
```

### 题目生成优化

```
后端:
  - 知识条目缓存 (相同文件不重复解析)
  - 题目生成批量化 (一次生成所有题目)
  - AI调用异步化 (可选，失败不阻塞)
```

### 答题判分优化

```
后端:
  - 单选题: O(1) 索引比较
  - 多选题: O(n) 集合比较
  - 填空题: O(k) 关键词匹配 (k=关键词数量)
  - 问答题: O(k) 关键词匹配

优化策略:
  - 关键词转小写缓存
  - 正则预编译
  - 短路求值
```

---

## 📊 监控指标

### 关键指标

```
- 并发用户数 (会话数量)
- 平均答题时长
- 题目生成成功率
- AI调用成功率
- 错题率分布
- 文件上传成功率
```

### 日志记录

```
- 文件上传: 文件名、大小、结果
- 题目生成: 会话ID、题目数量、耗时
- 答题记录: 已持久化到 answer_history.jsonl
- 错误记录: 异常类型、堆栈信息
```

---

## 🔐 安全检查流程

```
文件上传:
  ↓
检查文件大小 ≤ 700KB?
  NO → 返回错误
  ↓
检查文件类型 in [.txt, .md, .pdf]?
  NO → 返回错误
  ↓
生成UUID文件名
  ↓
保存到 uploads/
  ↓
解析文件内容
  ↓
解析失败?
    YES → 删除文件 + 返回错误
  ↓
返回成功
```

---

**系统流程图完成！** 🎉
